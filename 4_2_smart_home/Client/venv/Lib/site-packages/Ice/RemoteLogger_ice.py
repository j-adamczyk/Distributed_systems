# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.3
#
# <auto-generated>
#
# Generated from file `RemoteLogger.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy
import Ice.BuiltinSequences_ice

# Included module Ice
_M_Ice = Ice.openModule('Ice')

# Start of module Ice
__name__ = 'Ice'

if 'LogMessageType' not in _M_Ice.__dict__:
    _M_Ice.LogMessageType = Ice.createTempClass()
    class LogMessageType(Ice.EnumBase):
        """
        An enumeration representing the different types of log messages.
        Enumerators:
        PrintMessage -- The Logger received a print message.
        TraceMessage -- The Logger received a trace message.
        WarningMessage -- The Logger received a warning message.
        ErrorMessage -- The Logger received an error message.
        """

        def __init__(self, _n, _v):
            Ice.EnumBase.__init__(self, _n, _v)

        def valueOf(self, _n):
            if _n in self._enumerators:
                return self._enumerators[_n]
            return None
        valueOf = classmethod(valueOf)

    LogMessageType.PrintMessage = LogMessageType("PrintMessage", 0)
    LogMessageType.TraceMessage = LogMessageType("TraceMessage", 1)
    LogMessageType.WarningMessage = LogMessageType("WarningMessage", 2)
    LogMessageType.ErrorMessage = LogMessageType("ErrorMessage", 3)
    LogMessageType._enumerators = { 0:LogMessageType.PrintMessage, 1:LogMessageType.TraceMessage, 2:LogMessageType.WarningMessage, 3:LogMessageType.ErrorMessage }

    _M_Ice._t_LogMessageType = IcePy.defineEnum('::Ice::LogMessageType', LogMessageType, (), LogMessageType._enumerators)

    _M_Ice.LogMessageType = LogMessageType
    del LogMessageType

if '_t_LogMessageTypeSeq' not in _M_Ice.__dict__:
    _M_Ice._t_LogMessageTypeSeq = IcePy.defineSequence('::Ice::LogMessageTypeSeq', (), _M_Ice._t_LogMessageType)

if 'LogMessage' not in _M_Ice.__dict__:
    _M_Ice.LogMessage = Ice.createTempClass()
    class LogMessage(object):
        """
        A complete log message.
        Members:
        type -- The type of message sent to the Logger.
        timestamp -- The date and time when the Logger received this message, expressed
        as the number of microseconds since the Unix Epoch (00:00:00 UTC on 1 January 1970)
        traceCategory -- For a message of type trace, the trace category of this log message;
        otherwise, the empty string.
        message -- The log message itself.
        """
        def __init__(self, type=_M_Ice.LogMessageType.PrintMessage, timestamp=0, traceCategory='', message=''):
            self.type = type
            self.timestamp = timestamp
            self.traceCategory = traceCategory
            self.message = message

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.type)
            _h = 5 * _h + Ice.getHash(self.timestamp)
            _h = 5 * _h + Ice.getHash(self.traceCategory)
            _h = 5 * _h + Ice.getHash(self.message)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_Ice.LogMessage):
                return NotImplemented
            else:
                if self.type is None or other.type is None:
                    if self.type != other.type:
                        return (-1 if self.type is None else 1)
                else:
                    if self.type < other.type:
                        return -1
                    elif self.type > other.type:
                        return 1
                if self.timestamp is None or other.timestamp is None:
                    if self.timestamp != other.timestamp:
                        return (-1 if self.timestamp is None else 1)
                else:
                    if self.timestamp < other.timestamp:
                        return -1
                    elif self.timestamp > other.timestamp:
                        return 1
                if self.traceCategory is None or other.traceCategory is None:
                    if self.traceCategory != other.traceCategory:
                        return (-1 if self.traceCategory is None else 1)
                else:
                    if self.traceCategory < other.traceCategory:
                        return -1
                    elif self.traceCategory > other.traceCategory:
                        return 1
                if self.message is None or other.message is None:
                    if self.message != other.message:
                        return (-1 if self.message is None else 1)
                else:
                    if self.message < other.message:
                        return -1
                    elif self.message > other.message:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_Ice._t_LogMessage)

        __repr__ = __str__

    _M_Ice._t_LogMessage = IcePy.defineStruct('::Ice::LogMessage', LogMessage, (), (
        ('type', (), _M_Ice._t_LogMessageType),
        ('timestamp', (), IcePy._t_long),
        ('traceCategory', (), IcePy._t_string),
        ('message', (), IcePy._t_string)
    ))

    _M_Ice.LogMessage = LogMessage
    del LogMessage

if '_t_LogMessageSeq' not in _M_Ice.__dict__:
    _M_Ice._t_LogMessageSeq = IcePy.defineSequence('::Ice::LogMessageSeq', (), _M_Ice._t_LogMessage)

_M_Ice._t_RemoteLogger = IcePy.defineValue('::Ice::RemoteLogger', Ice.Value, -1, (), False, True, None, ())

if 'RemoteLoggerPrx' not in _M_Ice.__dict__:
    _M_Ice.RemoteLoggerPrx = Ice.createTempClass()
    class RemoteLoggerPrx(Ice.ObjectPrx):

        """
        init is called by attachRemoteLogger when a RemoteLogger proxy is attached.
        Arguments:
        prefix -- The prefix of the associated local Logger.
        logMessages -- Old log messages generated before "now".
        context -- The request context for the invocation.
        """
        def init(self, prefix, logMessages, context=None):
            return _M_Ice.RemoteLogger._op_init.invoke(self, ((prefix, logMessages), context))

        """
        init is called by attachRemoteLogger when a RemoteLogger proxy is attached.
        Arguments:
        prefix -- The prefix of the associated local Logger.
        logMessages -- Old log messages generated before "now".
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def initAsync(self, prefix, logMessages, context=None):
            return _M_Ice.RemoteLogger._op_init.invokeAsync(self, ((prefix, logMessages), context))

        """
        init is called by attachRemoteLogger when a RemoteLogger proxy is attached.
        Arguments:
        prefix -- The prefix of the associated local Logger.
        logMessages -- Old log messages generated before "now".
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_init(self, prefix, logMessages, _response=None, _ex=None, _sent=None, context=None):
            return _M_Ice.RemoteLogger._op_init.begin(self, ((prefix, logMessages), _response, _ex, _sent, context))

        """
        init is called by attachRemoteLogger when a RemoteLogger proxy is attached.
        Arguments:
        prefix -- The prefix of the associated local Logger.
        logMessages -- Old log messages generated before "now".
        """
        def end_init(self, _r):
            return _M_Ice.RemoteLogger._op_init.end(self, _r)

        """
        Log a LogMessage. Note that log may be called by LoggerAdmin before init.
        Arguments:
        message -- The message to log.
        context -- The request context for the invocation.
        """
        def log(self, message, context=None):
            return _M_Ice.RemoteLogger._op_log.invoke(self, ((message, ), context))

        """
        Log a LogMessage. Note that log may be called by LoggerAdmin before init.
        Arguments:
        message -- The message to log.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def logAsync(self, message, context=None):
            return _M_Ice.RemoteLogger._op_log.invokeAsync(self, ((message, ), context))

        """
        Log a LogMessage. Note that log may be called by LoggerAdmin before init.
        Arguments:
        message -- The message to log.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_log(self, message, _response=None, _ex=None, _sent=None, context=None):
            return _M_Ice.RemoteLogger._op_log.begin(self, ((message, ), _response, _ex, _sent, context))

        """
        Log a LogMessage. Note that log may be called by LoggerAdmin before init.
        Arguments:
        message -- The message to log.
        """
        def end_log(self, _r):
            return _M_Ice.RemoteLogger._op_log.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Ice.RemoteLoggerPrx.ice_checkedCast(proxy, '::Ice::RemoteLogger', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Ice.RemoteLoggerPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Ice::RemoteLogger'
    _M_Ice._t_RemoteLoggerPrx = IcePy.defineProxy('::Ice::RemoteLogger', RemoteLoggerPrx)

    _M_Ice.RemoteLoggerPrx = RemoteLoggerPrx
    del RemoteLoggerPrx

    _M_Ice.RemoteLogger = Ice.createTempClass()
    class RemoteLogger(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::Ice::RemoteLogger')

        def ice_id(self, current=None):
            return '::Ice::RemoteLogger'

        @staticmethod
        def ice_staticId():
            return '::Ice::RemoteLogger'

        def init(self, prefix, logMessages, current=None):
            """
            init is called by attachRemoteLogger when a RemoteLogger proxy is attached.
            Arguments:
            prefix -- The prefix of the associated local Logger.
            logMessages -- Old log messages generated before "now".
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'init' not implemented")

        def log(self, message, current=None):
            """
            Log a LogMessage. Note that log may be called by LoggerAdmin before init.
            Arguments:
            message -- The message to log.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'log' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Ice._t_RemoteLoggerDisp)

        __repr__ = __str__

    _M_Ice._t_RemoteLoggerDisp = IcePy.defineClass('::Ice::RemoteLogger', RemoteLogger, (), None, ())
    RemoteLogger._ice_type = _M_Ice._t_RemoteLoggerDisp

    RemoteLogger._op_init = IcePy.Operation('init', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_string, False, 0), ((), _M_Ice._t_LogMessageSeq, False, 0)), (), None, ())
    RemoteLogger._op_log = IcePy.Operation('log', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Ice._t_LogMessage, False, 0),), (), None, ())

    _M_Ice.RemoteLogger = RemoteLogger
    del RemoteLogger

if 'RemoteLoggerAlreadyAttachedException' not in _M_Ice.__dict__:
    _M_Ice.RemoteLoggerAlreadyAttachedException = Ice.createTempClass()
    class RemoteLoggerAlreadyAttachedException(Ice.UserException):
        """
        Thrown when the provided RemoteLogger was previously attached to a LoggerAdmin.
        """
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Ice::RemoteLoggerAlreadyAttachedException'

    _M_Ice._t_RemoteLoggerAlreadyAttachedException = IcePy.defineException('::Ice::RemoteLoggerAlreadyAttachedException', RemoteLoggerAlreadyAttachedException, (), False, None, ())
    RemoteLoggerAlreadyAttachedException._ice_type = _M_Ice._t_RemoteLoggerAlreadyAttachedException

    _M_Ice.RemoteLoggerAlreadyAttachedException = RemoteLoggerAlreadyAttachedException
    del RemoteLoggerAlreadyAttachedException

_M_Ice._t_LoggerAdmin = IcePy.defineValue('::Ice::LoggerAdmin', Ice.Value, -1, (), False, True, None, ())

if 'LoggerAdminPrx' not in _M_Ice.__dict__:
    _M_Ice.LoggerAdminPrx = Ice.createTempClass()
    class LoggerAdminPrx(Ice.ObjectPrx):

        """
        Attaches a RemoteLogger object to the local logger.
        attachRemoteLogger calls init on the provided RemoteLogger proxy.
        Arguments:
        prx -- A proxy to the remote logger.
        messageTypes -- The list of message types that the remote logger wishes to receive. An empty list means no filtering (send all message types).
        traceCategories -- The categories of traces that the remote logger wishes to receive. This parameter is ignored if messageTypes is not empty and does not include trace. An empty list means no filtering (send all trace categories).
        messageMax -- The maximum number of log messages (of all types) to be provided to init. A negative value requests all messages available.
        context -- The request context for the invocation.
        Throws:
        RemoteLoggerAlreadyAttachedException -- Raised if this remote logger is already attached to this admin object.
        """
        def attachRemoteLogger(self, prx, messageTypes, traceCategories, messageMax, context=None):
            return _M_Ice.LoggerAdmin._op_attachRemoteLogger.invoke(self, ((prx, messageTypes, traceCategories, messageMax), context))

        """
        Attaches a RemoteLogger object to the local logger.
        attachRemoteLogger calls init on the provided RemoteLogger proxy.
        Arguments:
        prx -- A proxy to the remote logger.
        messageTypes -- The list of message types that the remote logger wishes to receive. An empty list means no filtering (send all message types).
        traceCategories -- The categories of traces that the remote logger wishes to receive. This parameter is ignored if messageTypes is not empty and does not include trace. An empty list means no filtering (send all trace categories).
        messageMax -- The maximum number of log messages (of all types) to be provided to init. A negative value requests all messages available.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def attachRemoteLoggerAsync(self, prx, messageTypes, traceCategories, messageMax, context=None):
            return _M_Ice.LoggerAdmin._op_attachRemoteLogger.invokeAsync(self, ((prx, messageTypes, traceCategories, messageMax), context))

        """
        Attaches a RemoteLogger object to the local logger.
        attachRemoteLogger calls init on the provided RemoteLogger proxy.
        Arguments:
        prx -- A proxy to the remote logger.
        messageTypes -- The list of message types that the remote logger wishes to receive. An empty list means no filtering (send all message types).
        traceCategories -- The categories of traces that the remote logger wishes to receive. This parameter is ignored if messageTypes is not empty and does not include trace. An empty list means no filtering (send all trace categories).
        messageMax -- The maximum number of log messages (of all types) to be provided to init. A negative value requests all messages available.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_attachRemoteLogger(self, prx, messageTypes, traceCategories, messageMax, _response=None, _ex=None, _sent=None, context=None):
            return _M_Ice.LoggerAdmin._op_attachRemoteLogger.begin(self, ((prx, messageTypes, traceCategories, messageMax), _response, _ex, _sent, context))

        """
        Attaches a RemoteLogger object to the local logger.
        attachRemoteLogger calls init on the provided RemoteLogger proxy.
        Arguments:
        prx -- A proxy to the remote logger.
        messageTypes -- The list of message types that the remote logger wishes to receive. An empty list means no filtering (send all message types).
        traceCategories -- The categories of traces that the remote logger wishes to receive. This parameter is ignored if messageTypes is not empty and does not include trace. An empty list means no filtering (send all trace categories).
        messageMax -- The maximum number of log messages (of all types) to be provided to init. A negative value requests all messages available.
        Throws:
        RemoteLoggerAlreadyAttachedException -- Raised if this remote logger is already attached to this admin object.
        """
        def end_attachRemoteLogger(self, _r):
            return _M_Ice.LoggerAdmin._op_attachRemoteLogger.end(self, _r)

        """
        Detaches a RemoteLogger object from the local logger.
        Arguments:
        prx -- A proxy to the remote logger.
        context -- The request context for the invocation.
        Returns: True if the provided remote logger proxy was detached, and false otherwise.
        """
        def detachRemoteLogger(self, prx, context=None):
            return _M_Ice.LoggerAdmin._op_detachRemoteLogger.invoke(self, ((prx, ), context))

        """
        Detaches a RemoteLogger object from the local logger.
        Arguments:
        prx -- A proxy to the remote logger.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def detachRemoteLoggerAsync(self, prx, context=None):
            return _M_Ice.LoggerAdmin._op_detachRemoteLogger.invokeAsync(self, ((prx, ), context))

        """
        Detaches a RemoteLogger object from the local logger.
        Arguments:
        prx -- A proxy to the remote logger.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_detachRemoteLogger(self, prx, _response=None, _ex=None, _sent=None, context=None):
            return _M_Ice.LoggerAdmin._op_detachRemoteLogger.begin(self, ((prx, ), _response, _ex, _sent, context))

        """
        Detaches a RemoteLogger object from the local logger.
        Arguments:
        prx -- A proxy to the remote logger.
        Returns: True if the provided remote logger proxy was detached, and false otherwise.
        """
        def end_detachRemoteLogger(self, _r):
            return _M_Ice.LoggerAdmin._op_detachRemoteLogger.end(self, _r)

        """
        Retrieves log messages recently logged.
        Arguments:
        messageTypes -- The list of message types that the caller wishes to receive. An empty list means no filtering (send all message types).
        traceCategories -- The categories of traces that caller wish to receive. This parameter is ignored if messageTypes is not empty and does not include trace. An empty list means no filtering (send all trace categories).
        messageMax -- The maximum number of log messages (of all types) to be returned. A negative value requests all messages available.
        context -- The request context for the invocation.
        Returns a tuple containing the following:
        _retval -- The Log messages.
        prefix -- The prefix of the associated local logger.
        """
        def getLog(self, messageTypes, traceCategories, messageMax, context=None):
            return _M_Ice.LoggerAdmin._op_getLog.invoke(self, ((messageTypes, traceCategories, messageMax), context))

        """
        Retrieves log messages recently logged.
        Arguments:
        messageTypes -- The list of message types that the caller wishes to receive. An empty list means no filtering (send all message types).
        traceCategories -- The categories of traces that caller wish to receive. This parameter is ignored if messageTypes is not empty and does not include trace. An empty list means no filtering (send all trace categories).
        messageMax -- The maximum number of log messages (of all types) to be returned. A negative value requests all messages available.
        context -- The request context for the invocation.
        Returns: A future object for the invocation.
        """
        def getLogAsync(self, messageTypes, traceCategories, messageMax, context=None):
            return _M_Ice.LoggerAdmin._op_getLog.invokeAsync(self, ((messageTypes, traceCategories, messageMax), context))

        """
        Retrieves log messages recently logged.
        Arguments:
        messageTypes -- The list of message types that the caller wishes to receive. An empty list means no filtering (send all message types).
        traceCategories -- The categories of traces that caller wish to receive. This parameter is ignored if messageTypes is not empty and does not include trace. An empty list means no filtering (send all trace categories).
        messageMax -- The maximum number of log messages (of all types) to be returned. A negative value requests all messages available.
        _response -- The asynchronous response callback.
        _ex -- The asynchronous exception callback.
        _sent -- The asynchronous sent callback.
        context -- The request context for the invocation.
        Returns: An asynchronous result object for the invocation.
        """
        def begin_getLog(self, messageTypes, traceCategories, messageMax, _response=None, _ex=None, _sent=None, context=None):
            return _M_Ice.LoggerAdmin._op_getLog.begin(self, ((messageTypes, traceCategories, messageMax), _response, _ex, _sent, context))

        """
        Retrieves log messages recently logged.
        Arguments:
        messageTypes -- The list of message types that the caller wishes to receive. An empty list means no filtering (send all message types).
        traceCategories -- The categories of traces that caller wish to receive. This parameter is ignored if messageTypes is not empty and does not include trace. An empty list means no filtering (send all trace categories).
        messageMax -- The maximum number of log messages (of all types) to be returned. A negative value requests all messages available.
        Returns a tuple containing the following:
        _retval -- The Log messages.
        prefix -- The prefix of the associated local logger.
        """
        def end_getLog(self, _r):
            return _M_Ice.LoggerAdmin._op_getLog.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Ice.LoggerAdminPrx.ice_checkedCast(proxy, '::Ice::LoggerAdmin', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Ice.LoggerAdminPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Ice::LoggerAdmin'
    _M_Ice._t_LoggerAdminPrx = IcePy.defineProxy('::Ice::LoggerAdmin', LoggerAdminPrx)

    _M_Ice.LoggerAdminPrx = LoggerAdminPrx
    del LoggerAdminPrx

    _M_Ice.LoggerAdmin = Ice.createTempClass()
    class LoggerAdmin(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Ice::LoggerAdmin', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Ice::LoggerAdmin'

        @staticmethod
        def ice_staticId():
            return '::Ice::LoggerAdmin'

        def attachRemoteLogger(self, prx, messageTypes, traceCategories, messageMax, current=None):
            """
            Attaches a RemoteLogger object to the local logger.
            attachRemoteLogger calls init on the provided RemoteLogger proxy.
            Arguments:
            prx -- A proxy to the remote logger.
            messageTypes -- The list of message types that the remote logger wishes to receive. An empty list means no filtering (send all message types).
            traceCategories -- The categories of traces that the remote logger wishes to receive. This parameter is ignored if messageTypes is not empty and does not include trace. An empty list means no filtering (send all trace categories).
            messageMax -- The maximum number of log messages (of all types) to be provided to init. A negative value requests all messages available.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            Throws:
            RemoteLoggerAlreadyAttachedException -- Raised if this remote logger is already attached to this admin object.
            """
            raise NotImplementedError("servant method 'attachRemoteLogger' not implemented")

        def detachRemoteLogger(self, prx, current=None):
            """
            Detaches a RemoteLogger object from the local logger.
            Arguments:
            prx -- A proxy to the remote logger.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'detachRemoteLogger' not implemented")

        def getLog(self, messageTypes, traceCategories, messageMax, current=None):
            """
            Retrieves log messages recently logged.
            Arguments:
            messageTypes -- The list of message types that the caller wishes to receive. An empty list means no filtering (send all message types).
            traceCategories -- The categories of traces that caller wish to receive. This parameter is ignored if messageTypes is not empty and does not include trace. An empty list means no filtering (send all trace categories).
            messageMax -- The maximum number of log messages (of all types) to be returned. A negative value requests all messages available.
            current -- The Current object for the invocation.
            Returns: A future object for the invocation.
            """
            raise NotImplementedError("servant method 'getLog' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Ice._t_LoggerAdminDisp)

        __repr__ = __str__

    _M_Ice._t_LoggerAdminDisp = IcePy.defineClass('::Ice::LoggerAdmin', LoggerAdmin, (), None, ())
    LoggerAdmin._ice_type = _M_Ice._t_LoggerAdminDisp

    LoggerAdmin._op_attachRemoteLogger = IcePy.Operation('attachRemoteLogger', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Ice._t_RemoteLoggerPrx, False, 0), ((), _M_Ice._t_LogMessageTypeSeq, False, 0), ((), _M_Ice._t_StringSeq, False, 0), ((), IcePy._t_int, False, 0)), (), None, (_M_Ice._t_RemoteLoggerAlreadyAttachedException,))
    LoggerAdmin._op_detachRemoteLogger = IcePy.Operation('detachRemoteLogger', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Ice._t_RemoteLoggerPrx, False, 0),), (), ((), IcePy._t_bool, False, 0), ())
    LoggerAdmin._op_getLog = IcePy.Operation('getLog', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Ice._t_LogMessageTypeSeq, False, 0), ((), _M_Ice._t_StringSeq, False, 0), ((), IcePy._t_int, False, 0)), (((), IcePy._t_string, False, 0),), ((), _M_Ice._t_LogMessageSeq, False, 0), ())

    _M_Ice.LoggerAdmin = LoggerAdmin
    del LoggerAdmin

# End of module Ice

Ice.sliceChecksums["::Ice::LogMessage"] = "b3e905f1b794f505c1f817935be760"
Ice.sliceChecksums["::Ice::LogMessageSeq"] = "26c45475ae04c87944249ec14ebe9c"
Ice.sliceChecksums["::Ice::LogMessageType"] = "938bafca5970dc253c1e82a4c8ee234b"
Ice.sliceChecksums["::Ice::LogMessageTypeSeq"] = "cb11159511adf1a74eb2901796137d7"
Ice.sliceChecksums["::Ice::LoggerAdmin"] = "cba78eeef4c84241e3677c18bbccfb0"
Ice.sliceChecksums["::Ice::RemoteLogger"] = "8c4657be5994cd2ccf54ae795b97273"
Ice.sliceChecksums["::Ice::RemoteLoggerAlreadyAttachedException"] = "c0cffbaeb5ca2d0e1d4a0f328a701b"
